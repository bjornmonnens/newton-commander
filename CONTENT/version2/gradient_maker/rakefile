#
# Gradient generator
# Copyright 2010 - Simon Strandgaard <simon@opcoders.com>
#

def clamp01(value)
  return 0 if value < 0
  return 1 if value > 1 
  value
end

def nscolor_from_array(color_array)
  if color_array.length == 1
    w = clamp01(color_array[0])
    return '[NSColor colorWithCalibratedWhite:%.3f alpha:1.000]' % w
  end
  if color_array.length == 2
    w = clamp01(color_array[0])
    a = clamp01(color_array[0])
    return '[NSColor colorWithCalibratedWhite:%.3f alpha:%.3f]' % [w, a]
  end
  if color_array.length == 3
    r = clamp01(color_array[0])
    g = clamp01(color_array[1])
    b = clamp01(color_array[2])
    return '[NSColor colorWithCalibratedRed:%.3f green:%.3f blue:%.3f alpha:1.000]' % [r, g, b]
  end
  if color_array.length == 4
    r = clamp01(color_array[0])
    g = clamp01(color_array[1])
    b = clamp01(color_array[2])
    a = clamp01(color_array[2])
    return '[NSColor colorWithCalibratedRed:%.3f green:%.3f blue:%.3f alpha:%.3f]' % [r, g, b, a]
  end
  '[NSColor redColor]'
end
  
class Rule
  def is_thin_line
    false
  end
  def is_ramp
    false
  end
end

class GradientLine < Rule
  def initialize(color)
    @color = color
  end
  attr_reader :color

  def is_thin_line
    true
  end
end

class GradientRamp < Rule
  def initialize(colors)
    @colors = colors
  end
  attr_reader :colors

  def is_ramp
    true
  end
end

class Gradient
  def initialize
    @rules = []
  end
  
  def add(*colors)
    if colors.count == 1
      @rules << GradientLine.new(colors[0])
    elsif colors.count >= 2
      @rules << GradientRamp.new(colors)
    else
      raise 'one or more colors must be specified'
    end
  end
  
  def result(total_number_of_lines)
    number_of_ramps = 0
    number_of_lines = 0
    @rules.each do |rule|
       number_of_lines += 1 if rule.is_thin_line
       number_of_ramps += 1 if rule.is_ramp
    end
    
    lines_remaining = total_number_of_lines - number_of_lines
    if lines_remaining < 0
      puts 'ERROR: the gradient contains more lines than the requested height'
      return 'XXX'
    end

    ary = []
    

    location = 0
    @rules.each do |rule|
      if rule.is_thin_line
        nscolor = nscolor_from_array(rule.color)
        loc0 = "%.3f" % location
        location += 1.0 / total_number_of_lines.to_f
        loc1 = "%.3f" % location
        ary << "#{nscolor}, #{loc0},"
        ary << "#{nscolor}, #{loc1},"
        next
      end

      if rule.is_ramp
        raise 'should be positive' if number_of_ramps < 1
        
        lines_for_this_ramp = lines_remaining.to_f / number_of_ramps.to_f
        colors = rule.colors
        raise 'should be greater than 1' if colors.count < 2

        length = lines_for_this_ramp.to_f / total_number_of_lines.to_f
        location_increment = length.to_f / (colors.count - 1).to_f
        colors.each_with_index do |color, index|
          if index == 0
            nscolor = nscolor_from_array(colors[0])
            loc = "%.3f" % location
            ary << "#{nscolor}, #{loc},"
            next
          end
          
          begin
            nscolor = nscolor_from_array(color)
            location += location_increment
            loc = "%.3f" % location
            ary << "#{nscolor}, #{loc},"
          end
        end
      end
    end

    ary.unshift '[[[NSGradient alloc] initWithColorsAndLocations:'
    ary.push "nil] autorelease];  // height: #{total_number_of_lines} pixels"
    ary.join("\n")
  end
end

desc "table header gradient normal, tableHeaderGradient"
task :a1 do
  g = Gradient.new
  g.add([0.333])
  g.add([0.859], [0.804], [0.733])
  g.add([0.333])
  puts g.result(25)
end

desc "table header gradient normal pressed, tableHeaderPressedGradient"
task :a2 do
  g = Gradient.new
  g.add([0.333])
  g.add([0.769], [0.663], [0.584])
  g.add([0.333])
  puts g.result(25)
end

desc "table header gradient selected, tableHeaderSelectedGradient"
task :a3 do
  g = Gradient.new
  g.add([0.333])
  g.add([0.772, 0.812, 0.861], [0.649, 0.699, 0.782], [0.508, 0.575, 0.689])
  g.add([0.333])
  puts g.result(25)
end

desc "table header gradient selected pressed, tableHeaderSelectedPressedGradient"
task :a4 do
  g = Gradient.new
  g.add([0.333])
  g.add([0.665, 0.718, 0.788], [0.503, 0.567, 0.678], [0.346, 0.422, 0.551])
  g.add([0.333])
  puts g.result(25)
end

task :g1 do
  g = Gradient.new
  g.add([0.7, 0.7, 0.7])
  g.add([1.0, 0.0, 0.0])
  g.add([0.0, 0.0, 1.0], [1.0, 0.0, 0.0])
  g.add([0.0, 1.0, 0.0])
  puts g.result(10)
end

task :default => :g1

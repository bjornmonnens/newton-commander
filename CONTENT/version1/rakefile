require 'fileutils'

def log_write(filename, text)
  File.open(filename, 'a+') {|f| f.write(text) }
end

def reveal_in_finder(filename)
  path = File.expand_path(filename)
  ary = [
    "osascript",
    %(-e 'tell application "Finder"'),
    %(-e 'activate'),
    %(-e 'reveal posix file "%s"') % path,
    %(-e 'end tell')
  ]
  cmd = ary.join(' ')
#  puts cmd
  system cmd
end

def strip_executable(path_chdir, binary_name, log_file)
  print "stripping executable... "
  $stdout.flush
  
  log_write(log_file, "-------------\nstrip_executable: #{binary_name}\n\n")
  
  Dir.chdir(path_chdir) do
    size0 = File.size(binary_name)

    ENV["FILE_NAME"] = binary_name
    ENV["LOG_FILE"]  = log_file
    s = <<CMD
strip - "$FILE_NAME" >> "$LOG_FILE"
CMD
    system s

    size1 = File.size(binary_name)
    diff = size0 - size1
    log_write(log_file, "\nDONE -- #{size0} bytes before, #{size1} bytes after, #{diff} bytes saved\n\n")
  end

  puts "OK"
end

def strip_framework(path_chdir, binary_name, log_file)
  print "stripping framework... "
  $stdout.flush
  
  log_write(log_file, "-------------\nstrip_framework: #{binary_name}\n\n")
  
  Dir.chdir(path_chdir) do
    size0 = File.size(binary_name)

    ENV["FILE_NAME"] = binary_name
    ENV["LOG_FILE"]  = log_file
    s = <<CMD
strip -Sx - "$FILE_NAME" >> "$LOG_FILE"
CMD
    system s

    size1 = File.size(binary_name)
    diff = size0 - size1
    log_write(log_file, "\nDONE -- #{size0} bytes before, #{size1} bytes after, #{diff} bytes saved\n\n")
  end

  puts "OK"
end

def copy_without_unwanted_stuff(source_dir, dest_dir, log_file)
  print "copying... "
  $stdout.flush
  
  log_write(log_file, "-------------\ncopy_without_unwanted_stuff\n\n")
  
  exclude = <<EXCL
.DS_Store
Headers/
PrivateHeaders/
.svn/
.git/
.bzr/
*.h
*.m
*.mm
*.c
*.cpp
*.pch
*.xcconfig
InfoPlist.strings
# *.icns
EXCL

  # -C, --cvs-exclude    auto-ignore files in the same way CVS does
  # -a   archive mode
  # -v, --verbose               increase verbosity
  ENV["SOURCE_DIR"] = source_dir
  ENV["DEST_DIR"]   = dest_dir
  ENV["EXCLUDE"]    = exclude
  ENV["LOG_FILE"]   = log_file
  s = <<CMD
echo "$EXCLUDE" | /usr/bin/rsync -Cav --exclude-from=- --delete-excluded "$SOURCE_DIR"/ "$DEST_DIR" >> "$LOG_FILE"
CMD
  system s

  log_write(log_file, "\nDONE\n\n")

  puts "OK"
end

def create_zip(path_chdir, zipname, dirname, log_file)
  print "creating zip... "
  $stdout.flush
  
  Dir.chdir(path_chdir) do
    patterns = ['*.DS_Store*', '*.h', '*.m', '*.mm', '*.c', '*.cpp', '*.xcconfig']
    content = patterns.join("\n")
    File.open('exclude.lst', 'w+') {|f| f.write(content)}

    ENV["ZIP_NAME"] = zipname        
    ENV["DIR_NAME"] = dirname
    ENV["LOG_FILE"] = log_file
    s = <<CMD
zip -r -9 --symlinks "$ZIP_NAME" "$DIR_NAME" -x@exclude.lst >> "$LOG_FILE"
CMD
    system s

  end    

  puts "OK"
end

def create_tar(path_chdir, tarname, dirname, log_file)
  print "creating tar... "
  $stdout.flush
  
  Dir.chdir(path_chdir) do
    ENV["TAR_NAME"] = tarname        
    ENV["DIR_NAME"] = dirname
    ENV["LOG_FILE"] = log_file
    s = <<CMD
tar cvf "$TAR_NAME" "$DIR_NAME" >> "$LOG_FILE" 2>&1
CMD
    system s

  end    

  puts "OK"
end

def analyze_binary(input_file, output_file, analyzed_output_file)
  path_otx = '/usr/local/bin/otx'
  return unless FileTest.exist?(path_otx)

#  puts "otx"

  ENV["INPUT_FILE"] = input_file
  ENV["OUTPUT_FILE"] = output_file
  s = <<CMD
#{path_otx} -arch i386 "$INPUT_FILE" >> "$OUTPUT_FILE"
CMD
  system s

  if FileTest.exist?(output_file)
    lines = IO.readlines(output_file)
    result = []
    last_index = 0
    last_line = 'lines 0'
    lines.each_with_index do |line, index|
      if line =~ /^\S/
        diff = index - last_index
        result << [diff, last_line]
        last_index = index
        last_line = line
      end
    end
    result.sort! {|a, b| b[0] <=> a[0] }
    content = result.map {|a, b| "%4i %s" % [a, b]}.join('')
    File.open(analyzed_output_file, 'w+') {|f| f.write(content) }
  end
end

class DeployApplication
  
  def initialize
    @path_build_app = File.expand_path('NewtonCommander/build/Release/Newton Commander.app')
    @path_desktop = File.expand_path("~/Desktop")
    @path_destination = File.join(@path_desktop, Time.now.strftime('%Y_%m_%d_%H_%M_%S'))
    @app_dir = 'Newton Commander.app'
    @tmpdir_prefix = 'deploy_newton_commander'
    @zip_name = 'newton_commander.zip'
    @tar_name = 'newton_commander.tar'
    @resource_dir = File.expand_path("NewtonCommander/deploy_resources")
    @statistics = []
  end
  
  def main
    if FileTest.exist?(@path_destination)
      raise "ERROR: destination dir already exists. path: #{@path_destination}. Remove dir or try again"
    end
    FileUtils.mkdir(@path_destination)

    path_statistics = File.join(@path_destination, "statistics.txt")
    path_log_copy = File.join(@path_destination, "log_copy.txt")
    path_log_zip = File.join(@path_destination, "log_zip.txt")
    path_log_tar = File.join(@path_destination, "log_tar.txt")
    @path_log_strip = File.join(@path_destination, "log_strip.txt")
    @path_otx1_nc = File.join(@path_destination, "otx1_nc.txt")
    @path_otx2_nc = File.join(@path_destination, "otx2_nc.txt")
    @path_otx1_kit = File.join(@path_destination, "otx1_kit.txt")
    @path_otx2_kit = File.join(@path_destination, "otx2_kit.txt")
    @path_otx1_tab = File.join(@path_destination, "otx1_tab.txt")
    @path_otx2_tab = File.join(@path_destination, "otx2_tab.txt")
    @path_otx1_wrk = File.join(@path_destination, "otx1_wrk.txt")
    @path_otx2_wrk = File.join(@path_destination, "otx2_wrk.txt")
    path_app = File.join(@path_destination, @app_dir)
    path_zip = File.join(@path_destination, @zip_name)
    path_tar = File.join(@path_destination, @tar_name)

    copy_without_unwanted_stuff(@path_build_app, path_app, path_log_copy)
    
    Dir.chdir(path_app) do
      run_task_inside_dir
    end

    create_tar(@path_destination, @tar_name, @app_dir, path_log_tar)
    size_tar = register_size_of_file('tar (uncompressed)', File.join(@path_destination, @tar_name))

    create_zip(@path_destination, @zip_name, @app_dir, path_log_zip)
    size_zip = register_size_of_file('zip (compressed)', File.join(@path_destination, @zip_name))
    
    if size_tar > 100
      ratio = 100.0 * size_zip.to_f / size_tar.to_f
      @statistics << ("%7.2f%% compression ratio" % ratio)
    end

    reveal_in_finder(path_app)
    
    show_statistics(path_statistics)
  end
  
  def run_task_inside_dir
    strip_executable('Contents/MacOS', 'Newton Commander', @path_log_strip)
    strip_executable('Contents/MacOS', 'NewtonCommanderHelper', @path_log_strip)
    strip_framework('Contents/Frameworks/NCCore.framework/Versions/A', 'NCCore', @path_log_strip)
    strip_framework('Contents/Frameworks/PSMTabBarControl.framework/Versions/A', 'PSMTabBarControl', @path_log_strip)
    
    remove_broken_symlinks

    copy_readme
    
    set_permissions
    
    register_size_of_file('nc', 'Contents/MacOS/Newton Commander')
    register_size_of_file('wrk', 'Contents/MacOS/NewtonCommanderHelper')
    register_size_of_file('kit', 'Contents/Frameworks/NCCore.framework/Versions/A/NCCore')        
    register_size_of_file('tab', 'Contents/Frameworks/PSMTabBarControl.framework/Versions/A/PSMTabBarControl')
    
    print "analyzing... "
    $stdout.flush
    analyze_binary('Contents/MacOS/Newton Commander', @path_otx1_nc, @path_otx2_nc)
    analyze_binary('Contents/MacOS/NewtonCommanderHelper', @path_otx1_wrk, @path_otx2_wrk)
    analyze_binary('Contents/Frameworks/NCCore.framework/Versions/A/NCCore', @path_otx1_kit, @path_otx2_kit)
    analyze_binary('Contents/Frameworks/PSMTabBarControl.framework/Versions/A/PSMTabBarControl', @path_otx1_tab, @path_otx2_tab)
    puts "OK"

    touch_files
    unset_write_bit
  end
  
  def remove_broken_symlinks
    system('find . -type l ! -execdir test -e {} \; -delete')
  end
  
  def set_permissions
    system('chgrp -R staff *')
    
    system('find . -type f -exec chmod 0400 "{}" \;')
    system('find . -type d -exec chmod 0700 "{}" \;')
    system('find . -type l -exec chmod -h 0700 "{}" \;')
    FileUtils.chmod(0500, File.join('Contents/MacOS', 'Newton Commander'))
    FileUtils.chmod(0500, File.join('Contents/MacOS', 'NewtonCommanderHelper'))
  end
    
  def unset_write_bit
    # unset the write bit.. from rwx------ to r-x------
    system('find . -type l -exec chmod -h u-w "{}" \;')
    system('chmod -R u-w *')
  end
  
  def copy_readme
    FileUtils.cp(File.join(@resource_dir, 'readme.txt'), './Nothing to see here. Move along.')
  end

  def touch_files
    # IDEA: set date to YYYY-MM-DD 23:59:59
    system('find . -type f -exec touch "{}" \;')
    system('find . -type d -exec touch "{}" \;')
    # TODO: how to touch symlinks
  end
  
  def register_size_of_file(pretty_name, filename)
    size = File.size(filename)
    @statistics << "%8i bytes -- %s" % [size, pretty_name]
    return size
  end
  
  def show_statistics(path_statistics)
    puts '-----------------------------------'
    s = @statistics.join("\n")
    puts s
    log_write(path_statistics, s)
  end
  
end


desc "default is to deploy the app"
task :default => :deploy

desc "deploy the app"
task :deploy do
  DeployApplication.new.main
end
  

desc "find icns files and their size"
task :icons do
  Dir.chdir("/Applications") do
    cmd = 'find . -type f -name "*.icns" -exec stat -f "%z %N" "{}" \; | tee /tmp/icon_result.txt'
    system(cmd)
  end
  # sort -s -n -k 1
end


desc "find a header file in one of the standard locations"
task :header do
  pattern = "*ase.h"
  cmd = "find . -name '#{pattern}' -print"
  dirs = %w(
    /Developer/Library/Frameworks
    /usr/include
    /System/Library/Frameworks
  )
  dirs.each do |dir|
    puts "========= #{dir}"
    Dir.chdir(dir) do
      system(cmd)
    end
  end
end



desc "word count in the NCCore dir"
task :wc1 do
  cmd = 'find NCCore -type f \( '
  cmd += '-name "*.h" -or -name "*.m" -or -name "*.c"'
  cmd += ' \) | xargs wc -mlw'
  system(cmd)
end

desc "word count in the NewtonCommander dir"
task :wc2 do
  cmd = 'find NewtonCommander -type f \( '
  cmd += '-name "*.h" -or -name "*.m" -or -name "*.c"'
  cmd += ' \) | xargs wc -mlw'
  system(cmd)
end

desc "word count in the NewtonCommanderHelper dir"
task :wc3 do
  cmd = 'find NewtonCommanderHelper -type f \( '
  cmd += '-name "*.h" -or -name "*.m" -or -name "*.c"'
  cmd += ' \) | xargs wc -mlw'
  system(cmd)
end


desc "install the tool which we use to set the SETUID bit, during development of newtoncommander"
task :ift => :install_fixperm_tool
task :install_fixperm_tool do 
  system("sudo cp fixperm_on_newtoncommanders_worker.sh /usr/bin/.")
  puts "you must add the following line to /etc/sudoers"
  puts "neoneye  ALL=(ALL) NOPASSWD: /usr/bin/fixperm_on_newtoncommanders_worker.sh"
  puts "you can do this by typing: sudo visudo"
end


desc "restore default logging settings for ASL"
task :log0 do
  cmd = "sudo syslog -c syslogd -n"
  p cmd
  system(cmd)
end 


desc "show all debug log messages with ASL"
task :log1 do
  cmd = "sudo syslog -c syslogd -d"
  p cmd
  system(cmd)
end 


desc "restore master logging settings for ASL"
task :master_off do
  cmd = "sudo syslog -c 0 off"
  p cmd
  system(cmd)
end 


desc "show all master log messages with ASL"
task :master_on do
  cmd = "sudo syslog -c 0 -d"
  p cmd
  system(cmd)
end 


desc "write test message to ASL log"
task :test_log do
  cmd = 'syslog -s -l 7 "Houston, I think we have a problem."'
  p cmd
  system(cmd)
end 


desc "restart syslogd"
task :restart_syslogd do
  begin
    cmd = 'sudo launchctl unload /System/Library/LaunchDaemons/com.apple.syslogd.plist'
    p cmd
    system(cmd)
  end
  begin
    cmd = 'sudo launchctl load /System/Library/LaunchDaemons/com.apple.syslogd.plist'
    p cmd
    system(cmd)
  end
end 

desc "inspect ASL's log settings"
task :asl do
  begin
    cmd = "syslog -c syslogd"
    p cmd
    system(cmd)
  end
  begin
    cmd = "syslog -c 0"
    p cmd
    system(cmd)
  end
  begin
    puts "/etc/asl.conf contains:"
    s = IO.read('/etc/asl.conf')
    puts s.grep(/Newton|NewtonCommanderHelper|NCWorker/i)
    puts "\n\nit should contain:"
    txt =<<TXT
# save everything from NewtonCommander
? [= Sender Newton Commander] store
? [= Sender NewtonCommanderHelper] store
? [= Sender NCWorker] store
TXT
    puts txt
  end
end

